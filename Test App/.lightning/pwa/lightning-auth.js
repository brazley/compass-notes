// lightning-auth.js â€” generated by Lightning for Notes
(function() {
  'use strict';

  if (!window.lightning) return;

  function b64encode(buf) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buf)));
  }

  function b64decode(str) {
    var binary = atob(str);
    var bytes = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes.buffer;
  }

  function makeCryptoKey(prfOutput) {
    return crypto.subtle.importKey('raw', prfOutput, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']);
  }

  var PRF_SALT = new TextEncoder().encode('lightning-auth-v1');
  var rpId = window.location.hostname || 'localhost';

  window.lightning.auth = {
    version: '0.1.0',

    isAvailable: function() {
      if (!window.PublicKeyCredential) return Promise.resolve(false);
      return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()
        .catch(function() { return false; });
    },

    register: function(userId) {
      userId = userId || 'default';
      var challenge = new Uint8Array(32);
      crypto.getRandomValues(challenge);

      var options = {
        publicKey: {
          rp: { id: rpId, name: document.title || rpId },
          user: {
            id: new TextEncoder().encode(userId),
            name: userId,
            displayName: userId
          },
          challenge: challenge,
          pubKeyCredParams: [
            { type: 'public-key', alg: -7 },
            { type: 'public-key', alg: -257 }
          ],
          authenticatorSelection: {
            authenticatorAttachment: 'platform',
            userVerification: 'required',
            residentKey: 'preferred'
          },
          extensions: { prf: {} },
          timeout: 60000
        }
      };

      var doCreate = function() {
        return navigator.credentials.create(options).then(function(credential) {
          var credentialId = b64encode(credential.rawId);
          var key = '__auth_credential_' + userId;
          return window.lightning.data.set(key, credentialId).then(function() {
            return { credentialId: credentialId };
          });
        });
      };

      if (!document.hasFocus()) {
        return new Promise(function(resolve, reject) {
          setTimeout(function() { doCreate().then(resolve).catch(reject); }, 100);
        });
      }
      return doCreate();
    },

    authenticate: function(credentialId) {
      var challenge = new Uint8Array(32);
      crypto.getRandomValues(challenge);

      var rawId;
      try { rawId = b64decode(credentialId); }
      catch(e) { return Promise.resolve({ verified: false, key: null }); }

      var options = {
        publicKey: {
          rpId: rpId,
          challenge: challenge,
          allowCredentials: [{ type: 'public-key', id: rawId }],
          userVerification: 'required',
          extensions: { prf: { eval: { first: PRF_SALT } } },
          timeout: 60000
        }
      };

      return navigator.credentials.get(options).then(function(assertion) {
        var ext = assertion.getClientExtensionResults();
        var prfOutput = ext && ext.prf && ext.prf.results && ext.prf.results.first;

        if (prfOutput) {
          return makeCryptoKey(prfOutput).then(function(cryptoKey) {
            return { verified: true, key: cryptoKey };
          });
        }
        return { verified: true, key: null };
      }).catch(function() {
        return { verified: false, key: null };
      });
    },

    verify: function(userId) {
      userId = userId || 'default';
      var self = this;
      var storageKey = '__auth_credential_' + userId;

      return window.lightning.data.get(storageKey).then(function(credentialId) {
        if (!credentialId) {
          return self.register(userId).then(function(result) {
            return self.authenticate(result.credentialId);
          });
        }
        return self.authenticate(credentialId).then(function(result) {
          if (!result.verified) {
            return window.lightning.data.delete(storageKey).then(function() {
              return self.verify(userId);
            });
          }
          return result;
        });
      });
    },

    encrypt: function(plaintext, cryptoKey) {
      var iv = crypto.getRandomValues(new Uint8Array(12));
      var encoded = new TextEncoder().encode(plaintext);
      return crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, cryptoKey, encoded)
        .then(function(ciphertext) {
          var combined = new Uint8Array(12 + ciphertext.byteLength);
          combined.set(iv, 0);
          combined.set(new Uint8Array(ciphertext), 12);
          return b64encode(combined.buffer);
        });
    },

    decrypt: function(base64, cryptoKey) {
      var combined = new Uint8Array(b64decode(base64));
      var iv = combined.slice(0, 12);
      var ciphertext = combined.slice(12);
      return crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, cryptoKey, ciphertext)
        .then(function(plaintext) {
          return new TextDecoder().decode(plaintext);
        });
    }
  };

})();