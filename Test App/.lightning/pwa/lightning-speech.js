// lightning-speech.js — generated by Lightning for Notes
(function() {
  'use strict';
  if (!window.lightning) return;

  window.lightning.speech = {
    version: '0.1.0',

    // ── Recognition ────────────────────────────────────────────────────────

    recognition: {
      isAvailable: function() {
        return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
      },

      // Returns a configured SpeechRecognition instance
      // options: { continuous?, interimResults?, lang? }
      create: function(options) {
        var SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) return null;
        var r = new SR();
        r.continuous     = options && options.continuous     !== undefined ? options.continuous     : true;
        r.interimResults = options && options.interimResults !== undefined ? options.interimResults : true;
        r.lang           = (options && options.lang) ? options.lang : 'en-US';
        return r;
      }
    },

    // ── Synthesis ──────────────────────────────────────────────────────────

    synthesis: {
      isAvailable: function() {
        return !!window.speechSynthesis;
      },

      // options: { rate?, pitch?, volume?, lang?, voiceURI? }
      // Returns Promise that resolves when speech ends
      speak: function(text, options) {
        if (!window.speechSynthesis) return Promise.reject(new Error('Speech synthesis not supported'));
        // Cancel any in-progress speech
        window.speechSynthesis.cancel();
        return new Promise(function(resolve, reject) {
          var utterance = new SpeechSynthesisUtterance(text);
          if (options) {
            if (options.rate   != null) utterance.rate   = options.rate;
            if (options.pitch  != null) utterance.pitch  = options.pitch;
            if (options.volume != null) utterance.volume = options.volume;
            if (options.lang)           utterance.lang   = options.lang;
            if (options.voiceURI) {
              var voices = window.speechSynthesis.getVoices();
              var match = voices.find(function(v) { return v.voiceURI === options.voiceURI; });
              if (match) utterance.voice = match;
            }
          }
          utterance.onend   = function() { resolve(); };
          utterance.onerror = function(e) { reject(new Error(e.error)); };
          window.speechSynthesis.speak(utterance);
        });
      },

      cancel: function() {
        if (window.speechSynthesis) window.speechSynthesis.cancel();
      },

      // iOS bug: getVoices() returns [] synchronously — use onvoiceschanged
      getVoices: function() {
        return new Promise(function(resolve) {
          var voices = window.speechSynthesis.getVoices();
          if (voices.length) { resolve(voices); return; }
          window.speechSynthesis.onvoiceschanged = function() {
            resolve(window.speechSynthesis.getVoices());
          };
        });
      }
    }
  };
})();