// Service Worker â€” generated by Lightning for Notes
"use strict";

var CACHE_NAME = "notes-v1.0.0-1771454016";

var APP_SHELL = [
    "/",
    "/index.html",
    "/manifest.json",
    "/service-worker.js",
    "/lightning.js",
    "/lightning-auth.js",
    "/lightning-share.js",
    "/lightning-clipboard.js",
    "/lightning-wake.js",
    "/lightning-location.js",
    "/lightning-motion.js",
    "/lightning-speech.js",
    "/lightning-media.js",
    "/lightning-notifications.js",
    "/icons/icon-192.png",
    "/icons/icon-512.png",
    "/icons/apple-touch-icon.png"
];

var OFFLINE_HTML = '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Notes</title><meta name="viewport" content="width=device-width,initial-scale=1"><style>body{font-family:system-ui;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:#000;color:#fff}p{opacity:.6}</style></head><body><p>You\u2019re offline \u2014 Notes will be back when you reconnect.</p></body></html>';

// --- Install: precache app shell ---
self.addEventListener("install", function(event) {
    event.waitUntil(
        caches.open(CACHE_NAME).then(function(cache) {
            return cache.addAll(APP_SHELL);
        }).then(function() {
            return self.skipWaiting();
        })
    );
});

// --- Activate: purge stale caches, claim clients ---
self.addEventListener("activate", function(event) {
    event.waitUntil(
        caches.keys().then(function(keys) {
            return Promise.all(
                keys.filter(function(key) {
                    return key !== CACHE_NAME;
                }).map(function(key) {
                    return caches.delete(key);
                })
            );
        }).then(function() {
            return self.clients.claim();
        })
    );
});

// --- Fetch: routing strategy ---
self.addEventListener("fetch", function(event) {
    var request = event.request;

    // Non-GET requests pass through untouched
    if (request.method !== "GET") {
        return;
    }

    // API routes: network first, cache fallback
    if (request.url.indexOf("/api/") !== -1) {
        event.respondWith(
            fetch(request).then(function(response) {
                var clone = response.clone();
                caches.open(CACHE_NAME).then(function(cache) {
                    cache.put(request, clone);
                });
                return response;
            }).catch(function() {
                return caches.match(request);
            })
        );
        return;
    }

    // Lightning native bridge routes: pass through (future: route to Swift on macOS)
    if (request.url.indexOf("/lightning/") !== -1) {
        // Sprint 03: intercept and route to native bridge when __LIGHTNING_NATIVE__ is set
        // For now: network only (these are API calls, not cached resources)
        event.respondWith(fetch(request));
        return;
    }

    // Everything else: cache first, network fallback, offline fallback
    event.respondWith(
        caches.match(request).then(function(cached) {
            if (cached) {
                return cached;
            }
            return fetch(request).then(function(response) {
                var clone = response.clone();
                caches.open(CACHE_NAME).then(function(cache) {
                    cache.put(request, clone);
                });
                return response;
            });
        }).catch(function() {
            if (request.headers.get("accept") && request.headers.get("accept").indexOf("text/html") !== -1) {
                return new Response(OFFLINE_HTML, {
                    headers: { "Content-Type": "text/html; charset=utf-8" }
                });
            }
        })
    );
});

// --- Background Sync: replay queued mutations from IndexedDB ---
self.addEventListener("sync", function(event) {
    if (event.tag === "mutation-queue") {
        event.waitUntil(replayMutationQueue());
    }
});

function replayMutationQueue() {
    return openMutationStore().then(function(db) {
        return getAllMutations(db).then(function(mutations) {
            return mutations.reduce(function(chain, entry) {
                return chain.then(function() {
                    return fetch(entry.url, {
                        method: entry.method,
                        headers: entry.headers,
                        body: entry.body
                    }).then(function() {
                        return deleteMutation(db, entry.id);
                    });
                });
            }, Promise.resolve());
        });
    });
}

function openMutationStore() {
    return new Promise(function(resolve, reject) {
        var request = indexedDB.open("notes-mutations", 1);
        request.onupgradeneeded = function(event) {
            event.target.result.createObjectStore("queue", { keyPath: "id", autoIncrement: true });
        };
        request.onsuccess = function(event) { resolve(event.target.result); };
        request.onerror = function(event) { reject(event.target.error); };
    });
}

function getAllMutations(db) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction("queue", "readonly");
        var store = tx.objectStore("queue");
        var request = store.getAll();
        request.onsuccess = function(event) { resolve(event.target.result); };
        request.onerror = function(event) { reject(event.target.error); };
    });
}

function deleteMutation(db, id) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction("queue", "readwrite");
        var store = tx.objectStore("queue");
        var request = store.delete(id);
        request.onsuccess = function() { resolve(); };
        request.onerror = function(event) { reject(event.target.error); };
    });
}